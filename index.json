[{"categories":["React"],"contents":"\nThis project uses Node.js and React.js and connects to a json-server database. Follow the steps below to set up the project.\nClick here to view the code on GitHub\nSetup Install Node.js and npm on your local machine.\nClone the repository:\ngit clone https://github.com/JohnnyandLee/React_Memo Navigate to the project directory: cd React_Memo Install the project dependencies: npm install Start the server: npm run server Start the App: npm run start ","permalink":"https://johnnyandlee.github.io/blog/react-memo/","tags":["React","Node.js"],"title":"React Memo App"},{"categories":["C++"],"contents":"This project is implemented in C/C++ to build and develop 3 backend servers communicated by TCP and UDP, providing efficient and reliable data communication via socket programming.\nClick here to view the code on GitHub\nObjective Build our system with Unix socket programming.\nSet up two backend servers for the registration and processing of the available time for each individual. Server A processes a.txt to register the available time for each person. Server B processes b.txt.\nSet up a primary server for TCP communication with the client and UDP communication with the two backend servers.\nEstablish a streamlined and dependable meeting scheduler system.\nDescription Illustration of the system How to use Clone this repository to a 64-bit Ubuntu 16.04(Linux environment) git clone https://github.com/JohnnyandLee/SocketProgramming \u0026ldquo;make all\u0026rdquo; command in the terminal\n\u0026ldquo;./serverM\u0026rdquo; command in a terminal\n\u0026ldquo;./serverA\u0026rdquo; command in a different terminal\n\u0026ldquo;./serverB\u0026rdquo; command in a different terminal\n\u0026ldquo;./client\u0026rdquo; command in a different terminal\nthen follow the prompt for the client terminal to play this program\n","permalink":"https://johnnyandlee.github.io/blog/socket-programming/","tags":["C++","Socket","TCP","UDP"],"title":"Socket Programming"},{"categories":["Java"],"contents":"This project is implemented in Java to create a model that recognizes license plates in parallel.\nClick here to view the code on GitHub\nObjective Train our model by offering the capital English character and digits in Penitentiary Gothic font.\nOffer the images of license plates in California into our model to recognize license plates\u0026rsquo; number and turn then into text correctly.\nUse multi-threads to accelerate the process.\nReport the performance profile to identify the bottleneck of the code and evaluate how multi-threads in this case can help us to speed up.\nDescription Workflow Step 1: Training Data Feed our model with 4 images containing A-Z and 0-9 in Penitentiary Gothic font.\nConvert them to grayscale.\nResize them to 20 x 43 pixels.\nMake the character and digit as the key, and 1D integer array that stores the grayscale pixel value as a value.\n[255, 255, 64, 27, 128, \u0026hellip;., 0] length: 860\nAppend hard-coded character data to training Data to improve accuracy.\nStep 2: Test Data Load license plate images to trained model.\nCrop out top and bottom margins.\nUse edge detection to separate each character and digit.\nCalculate grayscale value of each character and digit in a 1D integer array.\n[226, 240, 65, 29, 124, \u0026hellip;., 0] length: 860\nUse 1NN method to find the nearest neighbor as the output character or digit.\nCompare the output and the label into a file.\nStep 3: Multi-threading speed up Incorporate multi threads method to train our models with data.\nRecognize abundant of license plate images simultaneously.\nReport the performance profile to identify the bottle neck of the code and evaluate how multi-threads in this case can help us to speed up.\nHow to use Clone this repository git clone https://github.com/JohnnyandLee/License_Plates_Recognition Single-Threaded Training, Single-Threaded Recognition: run the main function of App.java(just run useThread(1)) Multi-Threaded Training, Multi-Threaded Recognition: run the main function of App.java Single-Threaded Training, Multi-Threaded Recognition: run the main function of ALPR2.java Result Environment Operating System: MacOS Sonoma 14.2 CPU: Apple M1 Pro (10 cores, 3.22GHz) Profiling Tool: Intellij Profiler Single-Threaded Training, Single-Threaded Recognition Using the sample code from [2], we used single thread to train and recognize the test data(n = 30) at first. The result is as follows:\n# Time(ms) 1 49.05671660043299 2 46.057362500578165 3 48.585249999538064 4 47.26977499946952 5 46.15939580090344 6 47.3930583987385 7 47.39126249961555 8 47.2568790987134 9 51.24353750050068 10 50.26253329962492 Average 48.06757707 Multi-Threaded Training, Multi-Threaded Recognition (ALPR.java) With a brief understanding of how the single-threaded program works, we then started to parallelize the program using multi-threading and tried to find the best performance, and we got the following results:\n# of threads Time(ms) 1 48.26430410146713 2 16.126074999570847 3 14.657600000500679 5 18.433133399114013 6 16.172600001096725 10 23.696162501350045 15 32.35087089985609 30 61.7450833003968 One key observation from the above graph is that there is a significant improvement using multi-threading in terms of performance, but as the number of threads gets larger, the run time also increases. Therefore, we used the profiler to do a thorough analysis.\nFlame graph using 2 threads:\nFlame graph using 30 threads:\nComparing the above two graphs, we can see that using 30 threads will create a huge amount of overhead in ALPR.triain(), the model training process. Hence, we tried the following idea and it turned out to be the best result we can get.\nSingle-Threaded Training, Multi-Threaded Recognition (ALPR2.java) We found utilizing multiple threads for training the same font iteratively proved to be redundant and time-intensive. Finally, we decided to use one single thread to train the model to reduce the overhead while still using multi-threads to recognize the plates. The result is as follows:\n# of threads Time(ms) 1 27.904991699382663 2 12.330941600725055 3 8.415737500414252 5 5.632704200223088 6 5.021720798686147 10 4.205070799216628 15 5.060437500476837 30 4.273858400061727 The outcome indicates that the optimal approach for recognizing 30 license plates involves the utilization of 5-6 threads.\nReference The code was based on and derived from\n[1] Youtube channel: Oggi AI - Java image filter https://www.youtube.com/playlist?list=PLj8W7XIvO93p1v-f_eSP3yDu4PVK9Pbrt [2] GitHub Page: Joe James https://github.com/joeyajames/Java/tree/master/ALPR https://github.com/joeyajames/Java/tree/master/Image%20Filters Contributors Kuan-Te (Johnny) Lee Yi-Ning (Kenny) Lin Yi-Hsuan (Ashley) Chen ","permalink":"https://johnnyandlee.github.io/blog/license-plate-recognition/","tags":["Java","Multi-thread","Parallel"],"title":"License plate recognition with parallel computing"}]